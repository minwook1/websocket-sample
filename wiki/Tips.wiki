#summary Tips for websocket coding.

= Introduction =

 Tips for websocket coding.

= Details =
== mod_pywebsocket ==

 === handler name ===

  Suffix : `_wsh.py`<br>
  if script name is *var_wsh.py* and located in `<handler_root>`/foo/bar_wsh.py, resouce name is */foo/bar*. URI will be like as follows.
{{{
ws://somewhere/foo/bar
}}}

 === properties (request object) ===

  * ws_location

  uri of websocket handler
{{{
e.g.
ws://somewhere/foo/var  
}}}

  * ws_origin

  Indicates web sites which calls ws. If web site's uri is *http://somewhere/foo, * ws_origin will be
{{{
http://somewhere
}}}
  This property is useful in secure coding( _Origin-based security model_ ).

  * ws_protocol

  This property indicates sub-protocol name. 
{{{
e.g.
  NULL
}}}

  * ws_resource

  Resource name of ws. If ws_location is *ws://somewhere/foo/bar* resource name will be
{{{
/foo/bar
}}}

 === functions ===

  * web_socket_do_extra_handshake(request)

  This function is called if clients handshake message is valid. Valid message is like as follows.
{{{
GET /demo HTTP/1.1
Upgrade: WebSocket
Connection: Upgrade
Host: example.com
Origin: http://example.com
WebSocket-Protocol: sample
}}}

  If you consider "Origin-based security model", you should check *request.ws_origin* .
    
  If you *pass* this function, clients receives server messages like as follows and connection is established.
{{{
HTTP/1.1 101 Web Socket Protocol Handshake
Upgrade: WebSocket
Connection: Upgrade
WebSocket-Origin: http://example.com
WebSocket-Location: ws://example.com/demo
WebSocket-Protocol: sample
}}}
  If *raise exception* , server deny handshakes. 
  
  * web_socket_transfer_data(request)

  This function is called after connection established. This function manages *data frames.* If you want to close the connection, simply "return" this function.
  
  * message = msgutil.receive_message(request : request)
  
  Note::
    _message_ is 'unicode' (not 'string'), so you should use .encode('utf-8') if you want to treat as 'string' like as follows.
{{{
message = msgutil.receive_message(request)

message #=> u'あいう'
print type(message) #=> <type 'unicode'>
print message.encode('utf-8') #=> 'あいう'
}}}

  Receive message from client
{{{
%x00 + *( UTF8-char / %x80-%x7E ) + %xff
}}}

  * msgutil.send_message(request : _request_ , message : _unicode_ )

  Note::
    _message_ is 'unicode' (not 'string'), so you should use .decode('utf-8') if you want to send 'string'
{{{
message = 'あいうえお'
msgutil.send_message(request, message.decode('utf-8'))
}}}


  Send server initiate message to client.
{{{
%x00 + *( UTF8-char / %x80-%x7E ) + %xff
}}}

 === how to check Origin-based security model ===

  request.ws_origin value indicates which site is attempting to connect your ws server. To prevent unreliable web pages to use your ws server's resource, you may check this value.  
  If ws server's resource is restricted to *localhost, * script will be like as follows
{{{
def web_socket_do_extra_handshake(request):
  if request.ws_origin != 'http://localhost':
    raise "ws_origin error "+request.ws_origin
  pass  # if origin is acceptable.
}}}

 === don't forget to close thread ===

  In many cases, you'll type thread programming, because each _websocket_handler_ works individually (fork process). To share each client's message, shared file or some socket connection is reasonable and this phenomena requires thread programming. If you are in this situation, don't forget to close thread if the connection is going to close. Forgetting this process sometimes make zombie.

  python script will be as follows.
{{{
from mod_pywebsocket import msgutil

import thread

_CONNECTING_ = 0
_OPEN_ = 1
_CLOSE_ = 2

_status_ = _CONNECTING_

def proc():
  while True:
    if _status_ != _OPEN_:
      break
    ....

def web_socket_do_extra_handshake(request):
	pass  # Always accept.

def web_socket_transfer_data(request):
  global _status_
  _status_ = _OPEN_
  attr = ()
  thread.start_new_thread(proc().run, attr)
  while True:
    try:
      line = msgutil.receive_message(request)
      ...

    except Exception: # client calls ws.close()
      _status_ = _CLOSE_
      return # close connection
}}}
----
== apache's configuration ===

 === persistent connection ===

  _conf/extra/httpd-default.conf_
{{{
KeepAlive Off
}}}
  (default:On)

  _Note::_
   Don't forget to remove comment out (#) for "Include httpd-default.conf" in httpd.conf.

  Without this configuration, server retains connection for several seconds after ws connection was closed due to HTTP/1.1's persistent-connection. 

  _Note::_
   Delay time is configured in 
{{{
KeepAliveTimeout 5
}}}
   in extra/httpd-default.conf

----
== javascript ==
 === not to use encodeURIComponent ===

  Among multibytes-language people ( for example, japanese ), they tend to use encodeURIComponent() while sending message to server. In Websockets this manner works well, but it requires more bandwidth than spec required.<br>
  
  Websocket is designed to communicate with utf-8.
{{{
text-frame = (%x00) *( UTF8-char ) %xFF
  http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-68#page-6
}}}
  encodeURIComponent encodes UTF8 to ascii character. For example, 'あ' is encoded to '%E3%81%82'. In this case, these encoded string consume 9 bytes. However, 'あ' is 3 bytes in native utf-8 (%xe3%x81%x82). Therefore, sending messages in utf-8 ( this means not to use encodeURIComponent ) may be reasonable to keep network traffic lower and make shortage of messaging delay. So, you'd better to write web page in UTF-8 encode and use ws.send() simple way like as follows.
{{{
<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
</head>
<body>
....
<script type="text/javascript">
....
  var message = 'もももすももももものうち';
  ws.send(message);
</script>
</body>
</html>
}}}
  Note, not to type ` ws.send(encodeURIComponent()); `...

 === heartbeat ===

  After connection established, ws connection is closed by apache after several minutes without any clent side message ( even if server sent message in this minutes!!).

  _Note::_
   Default is 300 seconds ( "Timeout" in extra/httpd-default.conf ）

  Sending periodically message every few minutes avoid this situation.

  Javascript will be like as follows.
{{{
setInterval(function() {
  ws.send('Heartbeat');
}, 60000);
}}}

 === window.onunload ===

  Sometime, it seems to be keep ws connection in Chrome4+, even if window is closed/reloaded. To set *unload* event handler and call *ws.close()* will avoid this situation.

  Javascript will be like as follows.
{{{
window.onunload = function() {
  ws.close();
};
}}}